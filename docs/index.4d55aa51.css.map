{"mappings":"ACsRI,yCAGA,qDAOA,8DAMA,yNAaA,sCAGA,2DAKA,iHAQA","sources":["index.4d55aa51.css","LightsOut.vue"],"sourcesContent":["body {\n  font-family: ui-sans-serif, system-ui;\n}\n\n.trainer {\n  flex-direction: row;\n  width: 800px;\n  display: flex;\n}\n\n.grid {\n  flex-wrap: wrap;\n  width: 504px;\n  min-width: 504px;\n  display: flex;\n}\n\n.cell {\n  --webkit-user-select: none;\n  -webkit-user-select: none;\n  user-select: none;\n  color: #ddd;\n  background-color: #a1a1a1;\n  justify-content: center;\n  align-items: center;\n  width: 80px;\n  height: 80px;\n  margin: 2px;\n  display: flex;\n  position: relative;\n}\n\n.cell.active {\n  background-color: #00db00;\n}\n\n.cell .cellName {\n  z-index: 3;\n  font-size: 1rem;\n  position: absolute;\n}\n\n.cell .clickMe.active {\n  z-index: 2;\n  background-color: #000;\n  border-radius: 50%;\n  width: 30px;\n  height: 30px;\n  position: absolute;\n}\n\n.cell .clickMe.phase2Clicked {\n  background-color: #0003;\n}\n\n/*# sourceMappingURL=index.4d55aa51.css.map */\n","<script setup>\nimport { reactive, watch } from 'vue';\n\nconst BOARD_WIDTH = 6;\nconst BOARD_HEIGHT = 6;\n\nlet cells = reactive(Array.from({ length: BOARD_WIDTH * BOARD_HEIGHT }, (_, i) => ( {\n    id: i,\n    active: false,\n    clickMe: false,\n    phase2Clicked: false,\n})));\n\nlet model = reactive({\n    setupCustomBoard: false,\n    showHints: true,\n    strategyPhase: 1,\n});\n\nwatch(model.showHints, calculateHints);\n\nfunction onCellClick(cell) {\n    toggleCell(cells[cell.id]);\n    calculateHints();\n}\n\nfunction toggleCell(cell) {\n    cell.active = !cell.active;\n    if (model.strategyPhase === 2) {\n        if (!cell.clickMe) {\n            // bad click, please undo\n            cell.clickMe = true;\n        } else {\n            cell.phase2Clicked = !cell.phase2Clicked;\n        }\n    }\n    if (!model.setupCustomBoard) {\n        toggleAdjacent(cell);\n    }\n}\n\nfunction toggleAdjacent(cell) {\n    let left = cellLeft(cell.id);\n    if (left) {\n        left.active = !left.active;\n    }\n   \n    let right = cellRight(cell.id);\n    if (right) {\n        right.active = !right.active;\n    }\n\n    let up = cellUp(cell.id);\n    if (up) {\n        up.active = !up.active;\n    }\n\n    let down = cellDown(cell.id);\n    if (down) {\n        down.active = !down.active;\n    }\n}\n\nfunction cellLeft(ofId) {\n    const x = ofId % BOARD_WIDTH;\n    if (x > 0) {\n        return cells[ofId - 1];\n    }\n    return null;\n}\n\nfunction cellRight(ofId) {\n    const x = ofId % BOARD_WIDTH;\n    if (x < BOARD_WIDTH - 1) {\n        return cells[ofId + 1];\n    }\n    return null;\n}\n\nfunction cellUp(ofId) {\n    const y = Math.floor(ofId / BOARD_HEIGHT);\n    if (y > 0) {\n        return cells[ofId - BOARD_WIDTH];\n    }\n    return null;\n}\n\nfunction cellDown(ofId) {\n    const y = Math.floor(ofId / BOARD_HEIGHT);\n    if (y < BOARD_HEIGHT - 1) {\n        return cells[ofId + BOARD_WIDTH];\n    }\n    return null;\n}\n\n\nfunction randomizeBoard() {\n    model.strategyPhase = 1;\n    cells.forEach(cell => {\n        cell.active = Math.random() > 0.5;\n    });\n    calculateHints();\n}\n\nfunction clearBoard() {\n    model.strategyPhase = 1;\n    cells.forEach(cell => {\n        cell.active = false;\n    });\n    calculateHints();\n}\n\nfunction calculateHints() {\n    // clear all hints\n    cells.forEach(cell => {\n        if (model.strategyPhase === 2) {\n            // don't clear the top row if we are in phase 3\n            if (cell.id >= BOARD_WIDTH) {\n                cell.clickMe = false;\n            }\n        } else {\n            cell.clickMe = false;\n            cell.phase2Clicked = false;\n        }\n    });\n\n    if (model.strategyPhase === 2) {\n        var allPhase2Clicked = true;\n        for (let i = 0; i < BOARD_WIDTH; i++) {\n            if (cells[i].clickMe) {\n                if (!cells[i].phase2Clicked) {\n                    allPhase2Clicked = false;\n                }\n            }\n        }\n        if (allPhase2Clicked) {\n            model.strategyPhase = 3;\n            for (let i = 0; i < BOARD_WIDTH; i++) {\n                cells[i].clickMe = false;\n            }\n        }\n    }\n\n    var topDownClear = true;\n\n    // top down clear strategy\n    for (let row = 0; row < BOARD_HEIGHT - 1; row++) {\n        var anyActive = false;\n        for (let col = 0; col < BOARD_WIDTH; col++) {\n            const cell = cells[row * BOARD_WIDTH + col];\n            if (cell.active) {\n                anyActive = true;\n                let down = cellDown(cell.id);\n                if (down) {\n                    down.clickMe = true;\n                }\n            }\n        } \n        if (anyActive) {\n            topDownClear = false;\n            break;\n        }\n    }\n\n    // last row clear strategy\n    if (topDownClear) {\n        model.strategyPhase = 2;\n        let row = BOARD_HEIGHT - 1;\n        var anyActive = false;\n        var idsToTick = [];\n        for (let col = 0; col < BOARD_WIDTH; col++) {\n            const cell = cells[row * BOARD_WIDTH + col];\n            if (cell.active) {\n                anyActive = true;\n                let addIds = topRowCellsForBottomRowCell(cell.id);\n                idsToTick.push(...addIds);\n            }\n        }\n        // count the number of times an id is in the array\n        var countIdsToTick = {};\n        for (let i = 0; i < idsToTick.length; i++) {\n            countIdsToTick[idsToTick[i]] = (countIdsToTick[idsToTick[i]] || 0) + 1;\n        }\n        // if the count is even, then we can ignore it because clicking twice cancels itself out\n        var remainingIds = []\n        for (let i = 0; i < idsToTick.length; i++) {\n            if (countIdsToTick[idsToTick[i]] % 2 !== 0) {\n                remainingIds.push(idsToTick[i]);\n            }\n        }\n        var anyPhase2Ticked = false;\n        // finally tick the remaining ids\n        for (let i = 0; i < remainingIds.length; i++) {\n            cells[remainingIds[i]].clickMe = true;\n            anyPhase2Ticked = true;\n        }\n        if (anyPhase2Ticked) {\n            model.strategyPhase = 2;\n        } else {\n            model.strategyPhase = 3;\n        }\n\n        var allClear = true;\n        cells.forEach(cell => {\n            if (cell.active) {\n                allClear = false;\n            }\n        });\n        if (allClear) {\n            model.strategyPhase = 1;\n            cells.forEach(cell => cell.clickMe = false);\n        }\n    }\n}\n\n// this is the meat of the strategy\n// if you are left with cells at the bottom\n// then start from the top again ticking these cells off\n// now when you do the original strategy again, it will be clear at the bottom\n// https://gaming.stackexchange.com/a/339293/311986\nfunction topRowCellsForBottomRowCell(cellId) {\n    switch (cellId) {\n    case 30: return [0, 2];\n    case 31: return [3];\n    case 32: return [0, 4];\n    case 33: return [1, 5];\n    case 34: return [2];\n    case 35: return [3, 5];\n    }\n    return []\n}\n\n</script>\n\n<template>\n    <h1>6x6 Trainer</h1>\n    <div>\n        <label title=\"allows clicking one cell without affecting others\">\n            <input type=\"checkbox\" v-model=\"model.setupCustomBoard\" />\n            Setup Custom Board\n        </label>\n    </div>\n    <div>\n        <label>\n            <input type=\"checkbox\" v-model=\"model.showHints\" />\n            Show Hints\n        </label>\n        <button @click=\"calculateHints\">Calculate Hints</button>\n    </div>\n    <div>\n        <button @click=\"randomizeBoard\">Randomize</button>\n    </div>\n    <div>\n        <button @click=\"clearBoard\">Clear</button>\n    </div>\n    <div class=\"trainer\">\n        <div class=\"tips\">\n            <h2>Strategy Phase: {{ model.strategyPhase }}</h2>\n            <p v-if=\"model.strategyPhase == 1\">\n               First click all the cells one below the topmost active cell. \n            </p>\n            <p v-if=\"model.strategyPhase == 2\">\n               Now click the top row cells that are marked. \n            </p>\n            <p v-if=\"model.strategyPhase == 3\">\n               Finally, do the same strategy as in phase 1, but this time it will be clear at the bottom if you did it right. \n            </p>\n        </div>\n        <div class=\"grid\">\n            <div class=\"cell\" v-for=\"cell in cells\" :class=\"{ active: cell.active }\" @click=\"onCellClick(cell)\">\n                <div class=\"cellName\">{{ cell.id + 1 }}</div>\n                <div class=\"clickMe\" :class=\"{ active: model.showHints && cell.clickMe, phase2Clicked: model.showHints && cell.phase2Clicked }\"></div>\n            </div>\n        </div>\n    </div>\n</template>\n\n<style>\n    body {\n        font-family: ui-sans-serif, system-ui;\n    }\n    .trainer {\n        display: flex;\n        flex-direction: row;\n        width: 800px;\n    }\n    .tips {\n    }\n    .grid {\n        display: flex;\n        flex-wrap: wrap;\n        width: calc(84px * 6);\n        min-width: calc(84px * 6);\n    }\n    .cell {\n        position: relative;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        width: 80px;\n        height: 80px;\n        margin: 2px;\n        --webkit-user-select: none;\n        user-select: none;\n        color: #DDD;\n        background-color: #a1a1a1;\n    }\n    .cell.active {\n        background-color: #00db00;\n    }\n    .cell .cellName {\n        position: absolute;\n        z-index: 3;\n        font-size: 1rem;\n    }\n    .cell .clickMe.active {\n        position: absolute;\n        z-index: 2;\n        width: 30px;\n        height: 30px;\n        background-color: #000;\n        border-radius: 50%;\n    }\n    .cell .clickMe.phase2Clicked {\n        background-color: rgba(0, 0, 0, 0.2);\n    }\n</style>\n"],"names":[],"version":3,"file":"index.4d55aa51.css.map"}